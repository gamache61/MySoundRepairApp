<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Breakdown Analyzer</title>
    <link rel="manifest" href="manifest.json">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
        #container { max-width: 800px; margin: auto; text-align: center; }
        button { padding: 10px 20px; margin: 10px; font-size: 16px; cursor: pointer; }
        select { padding: 10px; font-size: 16px; }
        #status { font-size: 18px; color: #333; }
        #analysis { margin-top: 20px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); text-align: left; }
        canvas { display: block; margin: 20px auto; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div id="container">
        <h1>Sound Breakdown Analyzer</h1>
        <p>This offline web app records sounds from your microphone, analyzes them for potential breakdowns in everyday items (like appliances, cars, or machines), and provides basic diagnostics. Select a category, record a short clip (e.g., the sound of a running engine or rattling washer), and get an analysis based on frequency patterns.</p>
        <p><strong>Note:</strong> This is a simple demo using browser APIs—no data is sent anywhere. Analysis is basic (e.g., detects high-frequency noise for grinding or low rumbles for imbalances) and not professional advice.</p>
        
        <label for="category">Select Item Category:</label>
        <select id="category">
            <option value="appliance">Appliance (e.g., Washer, Fridge)</option>
            <option value="vehicle">Vehicle (e.g., Car Engine, Brakes)</option>
            <option value="machine">Machine (e.g., Fan, Pump)</option>
            <option value="structure">Structure (e.g., Door Hinge, Pipe)</option>
            <option value="other">Other</option>
        </select>
        
        <button id="startBtn">Start Recording</button>
        <button id="stopBtn" disabled>Stop Recording</button>
        <button id="analyzeBtn" disabled>Analyze Sound</button>
        
        <div id="status">Ready to record...</div>
        
        <canvas id="waveform" width="600" height="200"></canvas>
        
        <div id="analysis"></div>
    </div>

    <script>
        let audioContext;
        let mediaRecorder;
        let audioChunks = [];
        let analyzer;
        let scriptProcessor;
        let canvasCtx = document.getElementById('waveform').getContext('2d');
        let audioBlob;

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const status = document.getElementById('status');
        const categorySelect = document.getElementById('category');
        const analysisDiv = document.getElementById('analysis');

        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                mediaRecorder = new MediaRecorder(stream);
                
                const source = audioContext.createMediaStreamSource(stream);
                analyzer = audioContext.createAnalyser();
                analyzer.fftSize = 2048;
                source.connect(analyzer);
                
                scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);
                analyzer.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                scriptProcessor.onaudioprocess = drawWaveform;
                
                mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    audioChunks = [];
                    analyzeBtn.disabled = false;
                    status.textContent = 'Recording stopped. Ready to analyze.';
                };
                
                startBtn.onclick = () => {
                    audioChunks = [];
                    mediaRecorder.start();
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    analyzeBtn.disabled = true;
                    status.textContent = 'Recording...';
                };
                
                stopBtn.onclick = () => {
                    mediaRecorder.stop();
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    status.textContent = 'Processing...';
                };
                
                analyzeBtn.onclick = analyzeSound;
            } catch (err) {
                status.textContent = 'Error accessing microphone: ' + err.message;
            }
        }

        function drawWaveform(e) {
            const bufferLength = analyzer.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyzer.getByteTimeDomainData(dataArray);
            
            canvasCtx.clearRect(0, 0, 600, 200);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = 'rgb(0, 128, 0)';
            canvasCtx.beginPath();
            
            const sliceWidth = 600 / bufferLength;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * 100;
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
                x += sliceWidth;
            }
            canvasCtx.lineTo(600, 100);
            canvasCtx.stroke();
        }

        function analyzeSound() {
            status.textContent = 'Analyzing...';
            analysisDiv.innerHTML = '';
            
            // Simulate advanced analysis: In reality, process audioBlob for FFT
            // Here, use analyzer for a snapshot, but for demo, generate mock results
            const bufferLength = analyzer.frequencyBinCount;
            const freqData = new Uint8Array(bufferLength);
            analyzer.getByteFrequencyData(freqData);
            
            // Basic metrics: average low/mid/high freq energy
            let low = 0, mid = 0, high = 0;
            for (let i = 0; i < bufferLength / 3; i++) low += freqData[i];
            for (let i = bufferLength / 3; i < (2 * bufferLength / 3); i++) mid += freqData[i];
            for (let i = (2 * bufferLength / 3); i < bufferLength; i++) high += freqData[i];
            low /= (bufferLength / 3);
            mid /= (bufferLength / 3);
            high /= (bufferLength / 3);
            
            const category = categorySelect.value;
            let diagnosis = '';
            let advice = '';
            
            if (high > 100) {
                diagnosis = 'High-frequency noise detected – possible grinding, squeaking, or loose parts.';
                if (category === 'appliance') advice = 'Check for unbalanced loads or worn bearings. Try cleaning or tightening components.';
                else if (category === 'vehicle') advice = 'Could be brake pads or belt issues. Inspect visually or consult a mechanic.';
                else advice = 'Look for friction points or vibrations. Lubricate if possible.';
            } else if (low > 100) {
                diagnosis = 'Low rumble or humming – might indicate imbalance, motor strain, or leaks.';
                if (category === 'appliance') advice = 'Level the appliance or check for blockages.';
                else if (category === 'vehicle') advice = 'Possible engine or exhaust problem. Monitor for other symptoms.';
                else advice = 'Ensure stable mounting and no overload.';
            } else if (mid > 100) {
                diagnosis = 'Mid-range vibrations – could be normal operation or early wear.';
                advice = 'Record again under different conditions for comparison.';
            } else {
                diagnosis = 'Sound appears normal – no obvious issues detected.';
                advice = 'Continue monitoring regularly.';
            }
            
            analysisDiv.innerHTML = `
                <h2>Analysis Results</h2>
                <p><strong>Category:</strong> ${category.charAt(0).toUpperCase() + category.slice(1)}</p>
                <p><strong>Diagnosis:</strong> ${diagnosis}</p>
                <p><strong>Advice:</strong> ${advice}</p>
                <p><strong>Frequency Breakdown:</strong> Low: ${low.toFixed(2)}, Mid: ${mid.toFixed(2)}, High: ${high.toFixed(2)}</p>
            `;
            status.textContent = 'Analysis complete.';
        }

        initAudio();

        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('Service Worker registered!', reg))
                    .catch(err => console.error('Service Worker registration failed:', err));
            });
        }
    </script>
</body>
</html>